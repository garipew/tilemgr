<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Tilemap Editor</title>
	<style>
		:root {
			--bg: #0f0f0f;
			--panel: #1a1a1a;
			--panel-border: #2a2a2a;
			--accent: #4da6ff;
			--text: #e0e0e0;
		}

		* {
			box-sizing: border-box;
			font-family: system-ui, sans-serif;
		}

		body {
			margin: 0;
			background: var(--bg);
			color: var(--text);
			height: 100vh;
			display: flex;
			flex-direction: column;
		}

		/* ───────── Top Bar ───────── */
		#toolbar {
			height: 48px;
			display: flex;
			align-items: center;
			padding: 0 12px;
			background: var(--panel);
			border-bottom: 1px solid var(--panel-border);
			gap: 12px;
		}

		#toolbar button {
			background: var(--accent);
			color: #000;
			border: none;
			padding: 6px 12px;
			border-radius: 4px;
			cursor: pointer;
			font-weight: 600;
		}

		#toolbar button:hover {
			filter: brightness(1.1);
		}

		/* ───────── Main Layout ───────── */
		#editor {
			flex: 1;
			display: grid;
			grid-template-columns: 260px 1fr;
			overflow: hidden;
		}

		/* ───────── Left Panel ───────── */
		#sidebar {
			background: var(--panel);
			border-right: 1px solid var(--panel-border);
			display: flex;
			flex-direction: column;
			overflow: hidden;
		}

		#sidebar h3 {
			margin: 0;
			padding: 10px;
			font-size: 14px;
			font-weight: 600;
			border-bottom: 1px solid var(--panel-border);
		}

		#selector-container {
			padding: 8px;
			flex: 1;
			overflow-y: auto;
			overflow-x: hidden;
		}

		#selector {
			display: block;
			width: 100%;
			height: auto;
			background: #000;
			border: 1px solid var(--panel-border);
			image-rendering: pixelated;
		}

		/* ───────── Canvas Area ───────── */
		#canvas-container {
			flex: 1;
			overflow: auto;
			padding: 0;
			margin: 0;
			background: var(--bg);
		}

		#map {
			display: block;
			margin: 0;
			background: #000;
			border: none;
			image-rendering: pixelated;
		}
	</style>
</head>

<body>

	<!-- Top Toolbar -->
	<div id="toolbar">
		<button onclick="export_project()">Export Project</button>
	</div>

	<!-- Main Editor -->
	<div id="editor">

		<!-- Tile Selector -->
		<div id="sidebar">
			<h3>Tiles</h3>
			<div id="selector-container">
				<canvas id="selector"></canvas>
			</div>
		</div>

		<!-- Map Canvas -->
		<div id="canvas-container">
			<canvas id="map"></canvas>
		</div>

	</div>

	<script>
		const BACKGROUND = "#101010"
		const WID_MIN = 128
		const HEI_MIN = 128
		const FPS = 60
		const atlas = new Image();
		const ctx = map.getContext("2d")
		const selector_ctx = selector.getContext("2d")

		function export_project() {
			const a = document.createElement("a");
			a.href = location.pathname + "/export";
			a.download = "";
			document.body.appendChild(a);
			a.click();
			a.remove();
		}

		function clear() {
			ctx.fillStyle = BACKGROUND
			ctx.fillRect(0, 0, map.width, map.height)
		}

		function draw_selector(frames) {
			if(frames == null)
			{
				return
			}

			const tileW = wid * scale.x / 2
			const tileH = hei * scale.y / 2

			const tilesPerRow = Math.floor(selector.width / tileW);
			const rowsNeeded = Math.ceil(frames.length / tilesPerRow);

			selector.height = rowsNeeded * tileH;
			selector_ctx.clearRect(0, 0, selector.width, selector.height);

			col = 0
			row = 0
			frames.forEach( (frame, i) => {
				selector_ctx.drawImage(
					atlas,
					frame.x, frame.y, wid, hei,
					col * tileW, row * tileH, tileW, tileH
				)
				col++;
				if(col >= tilesPerRow)
				{
					row++
					col = 0
				}
			});
		}

		function draw(tilemap) {
			if(tilemap == null) {
				return
			}

			tilemap.forEach( (row, i) => {
				row.forEach( (col, j) => {
					if(col == 0 || col > frames.length) {
						return
					}
					let scaled = {x: wid * scale.x, y: hei * scale.y}
					ctx.drawImage(
						atlas,
						frames[col-1].x, frames[col-1].y, wid, hei,
						j * scaled.x, i * scaled.y, scaled.x, scaled.y
					)
				})
			})
		}

		function readInt32LE(arr, offset) {
			return (
				arr[offset] |
				(arr[offset + 1] << 8) |
				(arr[offset + 2] << 16) |
				(arr[offset + 3] << 24)
			);
		}

		function decompress(compressed) {
			const height = readInt32LE(compressed, 4);
			const width  = readInt32LE(compressed, 0);

			const decompressed = Array.from({ length: height }, () => new Uint8Array(width));

			let prologue = 8;
			let repeats = 0;
			let element = 0;
			let wid = 0;
			let hei = 0;

			for (let i = prologue; i + 1 < compressed.length; i += 2) {
				repeats = compressed[i];
				element = compressed[i + 1];

				for (let j = 0; j < repeats; j++) {
					decompressed[hei][wid] = element;
					wid += 1;

					if (wid >= width) {
						wid = 0;
						hei += 1;
					}

					if (hei >= height) {
						return decompressed;
					}
				}
			}

			return decompressed;
		}

		function send_update(ws, e) {
			const rect = map.getBoundingClientRect()

			mouse.x = Math.floor((e.clientX - rect.left) / (wid * scale.x))
			mouse.y = Math.floor((e.clientY - rect.top) / (hei * scale.y))
			if(!erase) {
				ws.send(JSON.stringify({x: mouse.x, y: mouse.y, tile: tile_selected}))
			} else {
				ws.send(JSON.stringify({x: mouse.x, y: mouse.y, tile: 0}))
			}
		}

		let mouse = {x: 0, y: 0, down: false}
		let tile_selected = 1
		let stage = 0
		let frames = null
		let wid = 16
		let hei = 16
		let cols = 0
		let rows = 0
		let scale = {x: 1, y: 1}
		var tilemap = null
		const ws = new WebSocket(location.pathname + "/ws")
		ws.addEventListener("message", (event) => {
			var msg = JSON.parse(event.data)
			switch(stage){
				case 0:
					cols = msg.Wid
					rows = msg.Hei
					wid = msg.TileWid
					hei = msg.TileHei
					let compressed = msg.compressed.slice()
					tilemap = decompress(compressed)
					if(wid <= WID_MIN || hei <= HEI_MIN) {
						scale.x = WID_MIN/wid
						scale.y = HEI_MIN/hei
					}
					map.width = wid * scale.x * cols;
					map.height = hei * scale.y * rows;
					stage++
					break
				case 1:
					frames = msg.frames.slice()
					atlas.src = "/" + msg.ImgPath
					const sidebar = document.getElementById("selector-container")
					selector.width = sidebar.clientWidth
					selector.height = sidebar.clientHeight
					atlas.onload = () => {
						clear()
						draw(tilemap)
						draw_selector(frames)
					}
					stage++
					break
				default:
					tilemap[msg.y][msg.x] = msg.tile
					clear()
					draw(tilemap)
					draw_selector(frames)
			}
		})

		let erase = false

		map.addEventListener("contextmenu", (e) => {
			e.preventDefault();
		});

		map.addEventListener("mousedown", (e) => {
			mouse.down = true
			erase = true
			if(e.button == 0) {
				erase = false
			}
			send_update(ws, e)
		})

		map.addEventListener("mouseup", (e) => {
			mouse.down = false
		})

		map.addEventListener("mousemove", (e) => {
			if(!mouse.down) {
				return
			}
			send_update(ws, e)
		})

		map.addEventListener("mouseleave", (e) => {
			mouse.down = false
		})

		selector.addEventListener("mousedown", (e) => {
			const rect = selector.getBoundingClientRect();
			const containerRect = document.getElementById("selector-container").getBoundingClientRect();
			const scrollTop = document.getElementById("selector-container").scrollTop;

			const tileW = wid * scale.x / 2;
			const tileH = hei * scale.y / 2;
			const tilesPerRow = Math.floor(selector.width / tileW);

			// Calculate position relative to canvas, accounting for scroll
			const x = e.clientX - rect.left;
			const y = (e.clientY - containerRect.top) + scrollTop;

			const tileX = Math.floor(x / tileW);
			const tileY = Math.floor(y / tileH);

			const idx = tileX + tileY * tilesPerRow;

			if(e.button === 0) {
				if(idx < 0 || idx >= frames.length) {
					return;
				}
				tile_selected = idx + 1;
			}		})
	</script>
</body>
